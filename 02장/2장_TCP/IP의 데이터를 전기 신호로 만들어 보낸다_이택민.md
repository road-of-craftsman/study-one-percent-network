## 1. 소켓을 작성한다

### 1.프로토콜 스택의 내부 구성

![protocol_stack](https://velog.velcdn.com/images%2Fkot8585%2Fpost%2F195c1277-fa32-415c-b037-a33a3868e6d0%2Fimage.png)

- TCP
  - 브라우저나 메일 등의 일반적인 애플리케이션이 데이터를 송/수신할때 사용
- UDP
  - DNS 서버 조회 등 짧은 제어용 데이터 송수신의 경우 사용
- IP
   - ICMP
     - 패킷을 운반할때 발생하는 오류를 통지하거나 제어용 메시지를 통지할 때 사용
   - ARP
     - IP 주소에 대응하는 이더넷의 MAC 주소를 조사할때 사용
- LAN 드라이버
  - LAN 어댑터의 하드웨어를 제어

<br> 

### 2. 소켓의 실체는 통신 제어용 제어 정보
프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있다

통신 동작을 제어하기 위한 제어 정보를 기록한다.

- 통신 상대의 IP 주소
- 포트 번호
- 통신 동작 상태
<br>

프로토콜 스택은 이러한 제어정보를 참조하며 동작한다
<br>

### 3. 소켓을 호출했을 때의 동작
소켓을 만들 때 프로토콜 스택이 최초로 하는 일은 소켓 한 개 분량의 메모리 영역을 확보하는 것
<br>

소켓의 제어 정보를 기록하는 메모리 영역은 처음부터 존재하는 것이 아니므로 먼저 그것을 확보해 두어야 한다.
<br>

소켓을 작성한 후 송/수신 동작이 시작되지 않은 초기 상태이므로 초기 상태임을 나타내는 제어 정보를 소켓의 메모리 영역에 기록한다. 이과정을 통해 소켓이 만들어진다.
<br>

소켓이 만들어지면 소켓을 나타내는 **디스크립터**를 애플리케이션에 알려준다.
<br>

**디스크립터**는 프로토콜 스택의 내부에 있는 다수의 소켓 중 어느 것을 가르키는지를 나타내는 번호표와 같은 정보
<br>

디스크립터를 받은 애플리케이션은 이후 프로토콜 스택에 데이터 송/수신 동작을 의뢰할 때 디스크립터를 통지한다.
<br>

소켓에는 누구와 누가 통신하는지 등등의 모든 정보가 전부 기록되어있으므로 디스크립터가 어느 소켓을 가르키는지만 알면 프로토콜 스택쪽에서 알 수 있기 때문에 통신 상대의 정보를 애플리케이션에서 일일이 통지받을 필요가 없어진다.
<br>

## 2. 서버에 접속한다

### 1. 접속의 의미
<br>

소켓을 만들면 애플리케이션(브라우저)은 connect을 호출한 후 프로토콜 스택은 자기쪽의 소케승ㄹ 서버측 소켓에 접속한다.
<br>

소켓을 작성한 후 바로 애플리케이션에서 데이터 송신 의뢰가 오면 프로토콜 스택은?
<br>

소켓을 만든 직후는 기록되어 있는게 없어 통신 상대가 누구인지도 모른다.
<br>

socket을 호출하여 소켓을 만드는 동작만으로는 프로토콜 스택에는 아무 것도 전달되지 않기 때문에 서버의 IP 주소나 포트 번호를 프로토콜 스택에 알리는 동작이 필요한데 이것이 접속 동작의 한가지 예이다.
<br>

클라이언트가 서버측에 통신 동작의 개시를 전달하는 것도 접속 동작의 역할 중 하나이다.
<br>

접속 동작의 첫번째 동작은 통신 상대와의 제어 정보를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송/수신이 가능한 상태로 만드는 것
<br>

데이터 송/수신 동작을 실행할 때는 송/수신하는 데이터를 일시적으로 저장하는 메모리 영역이 필요한데, 이 메모리 영역을 **버퍼 메모리**라고 부른다.
<br>

버퍼메모리 확보도 접속 동작을 할 때 실행된다.
<br>

### 2. 맨앞부분에 제어 정보를 기록한 헤더를 배치한다.
통신 동작에 이용하는 제어 정보는 다음의 두 종류

- 헤더에 기입되는 정보
  - TCP 헤더
  - 이더넷 헤더 (MAC 헤더)
  - IP 헤더
- 소켓(프로토콜 스택의 메모리 영역)에 기록되는 정보
<br>

### 3. 접속 동작의 실제
<br>

connect(<디스크립터>, <서버측의 IP 주소와 포트 번호>, ...)
<br>

명령 시(IP주소와 포트번호 작성 시) 프로토콜 스택의 TCP 담당 부분에 전달 된다.
<br>

중요한 것은 송신처와 수신처의 **포트번호**
<br>

이를 통해 송신처가 되는 클라이언트측의 소켓과 수신처가 되는 서버측의 소켓을 지정할 수 있다.
<br>

접속해야 하는 소켓이 어느 것인지 확실히 하고 **컨트롤 비트 SYN** 비트를 1로 만든다.
<br>

접속 동작의 첫 걸음은 TCP 담장 부분에서 접속을 나타내는 제어 정보를 기록한 TCP 헤더를 만드는 것
<br>

TCP 헤더의 송신처와 수신처의 포트 번호로 접속하는 소켓을 지정한다.
<br>

TCP 헤더를 만들면 이것을 IP 담당 부분에 건네주어 송신하도록 의뢰하고, IP 담당 부분이 패킷 송신 동작을 실행한 후 네트워크를 통해 패킷이 서버에 도착하면 서버측의 IP 담당 부분이 이것을 받아 조사하여 기록되어 있는 수신처 포트 번호에 해당하는 소켓을 찾아낸다.
<br>

접속을 기다리는 (LISTENING) 상태에 있는 소켓 중에서 TCP 헤더의 수신처 포트 번호와 같은 번호가 기록된 것이 해당하는 소켓이다.
<br>

클라이언트와 마찬가지로 송신처와 수신처의 포트 번호나 SYN 비트 등을 설정한 TCP 헤더를 만든다.
<br>

그리고 응답을 돌려보낼 때 **ACK** 라는 **컨트롤 비트**도 1로 만든다. 
→ 패킷을 받은 것을 알리기 위한 동작
<br>

네트워크에는 오류가 있을 수 있으므로 패킷이 없어지는 경우에는 패킷이 도착한 것을 확인하는 동작이 진행된다.
<br>

이것을 확인하기 위해 ACK 비트를 1로 만드는 것
<br>

TCP 헤더를 IP 담당 부분에 건네주어 클라리언트에 반송하도록 의뢰한다.
<br>

그러면 패킷이 클라이언트로 돌아오고 IP 담당 부분을 경유하여 TCP 담당부분에 도착한다.
<br>

SYN이 1이면 접속 성공이므로 소켓에 서버의 IP 주소나 포트 번호 등과 함께 소켓에 접속 완료를 나타내는 제어 정보를 기록한다.
<br>

서버가 응답을 돌려보낼 때 ACK 비트를 1로 만들었는데, 이것과 같이 패킷이 도착한 것을 서버에 알리기 위해 ACK 비트를 1로 만든 TCP 헤더를 반송한다.
<br>

이것이 서버에 도착하면 접속 동작의 대화가 끝난다.
<br>

이로써 소켓은 데이터를 송/수신 할 수 있는 상태가 된다.
<br>

파이프와 같은것으로 소켓이 연결되었다고 생각 할 수 있다. (실제로는 무언가로 연결되어 있지 않다.)
<br>

파이프와 같은 것을 **커넥션**(세션) 이라고 한다. 커넥션은 데이터 송/수신 동작을 계속 하고 있는 동안, 즉 close를 호출하여 연결을 끊을 때까지 계속 존재한다.
<br>

## 3. 데이터를 송/수신한다

### 1. 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다.

1. connection에서 애플리케이션에 제어가 되돌아오면 데이터 송/수신 동작에 들어간다.
<br>

2. write를 호출하여 송신 데이터를 프로토콜 스택에 건네주는 곳부터 시작된다.
<br>

3. 프토토콜 스택은 받은 데이터의 내용에 무엇이 쓰여있는지 알지 못한다.(송신 데이터의 길이 지정 해당 길이만큼만 바이너리 데이터가 1바이트씩 차례로 나열되어 있다고 인식)
<br>

4. 받은 데이터를 바로 송신하지 않고 내부에 있는 송신용 버퍼 메모리 영역에 저장
<br>

5. 애플리케이션이 다음 데이터를 건네주길 기다린다.
<br>

어느 정도 까지 저장한 후 송신 동작을 할지는 아래와 같은 요소로 판단한다.
**MTU(한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이)** 라는 매개변수를 바탕으로 판단한다. (이더넷에선 보통 1500바이트)

MTU에는 패킷의 맨 앞부분에 헤더가 포함되어 있는데 이부분을 제외한 것이 하나의 패킷으로 운반할 수 있는 **데이터의 최대 길이**가 된다. 이것을 **MSS** 라 한다
<br>

- MTU
    - 패킷 한 개로 운반할 수 있는 디지털 데이터의 최대 길이, 이더넷에서는 보통 1500 바이트
- MSS
    - 헤더를 제외하고 한개의 패킷으로 운반할 수 있는 TCP의 데이터의 최대 길이

프로토콜 스택 내부에 타이머가 있어서 이것으로 일정 시간 이상 경과하면 패킷을 송신한다.

프로토콜 스택에만 송신의 타이밍을 맡기면 문제가 생길 수 있으니 애플리케이션 측에서 제어할 수 있는 데이터 송신을 의뢰할 때 옵션을 지정할 수 있다.

‘버퍼에 머물지 않고 바로 송신할 것'이라고 지정하면 프로토콜 스택은 버퍼에 머물지 않고 송신 동작을 실행한다.

<br>

### 2. 데이터가 클 때는 분할하여 보낸다

데이터가 길경우 (FormData)
<br>

송신 버퍼에 저장된 데이터는 MSS의 길이를 초과하므로 다음 데이터를 기다릴 필요가 없다.
<br>

따라서 송신 버퍼에 들어있는 데이터를 맨 앞부터 차례대로 MSS의 크기에 맞게 분할하고, 분할한 조각을 한 개씩 패킷에 넣어 송신한다.
<br>

맨 앞부분에 TCP 헤더를 부가, 그리고 소켓에 기록되어 있는 제어정보를 바탕으로 송신처 보트 번호나 수신처 포트 번호 등 필요한 항목을 기록하고, IP 담당 부분에 건네주어 송신 동작을 실행한다.

<br>

### 3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다

TCP에는 송신한 패킷이 상대에게 올바르게 도착했는지 확인하고, 도착하지 않았으면 다시 송신하는 기능이 있다.
<br>

데이터 조각을 송신할 때 세어둔 값을 TCP 헤더에 기록하는데, **시퀀스 번호**라 한다.
<br>

패킷 전체 길이에서 헤더 길이를 빼면 데이터의 크기를 계산할 수 있다.
<br>

수신측은 누락이 없는 것을 확인하고 수신한 데이터와 합쳐서 데이터를 몇 번째 바이트까지 수신한 것인지 계산하고, 그 값을 TCP 헤더의 **ACK 번호 에** 기록하여 송신측에 알려준다.  **제어 비트의 ACK 비트도 1로 하여 유효하다는 의미가 된다.**
<br>

ACK 번호를 되돌려주는 동작을 **수신 확인 응답** 이라고 부른다.
<br>

처음 클라이언트 측에서 SYN을 보낼때 시퀀스 번호에도 값을 설정하여 보낸다. (시퀀스 번호의 값이 초기값을 나타낸다)
→ 시퀀스 번호는 난수값 (악의적인 공격 우려)

1. 시퀀스 번호의 초기값을 클라이언트에서 산출하여 서버로 보내는 데이터에 담아 서버에 통지한다.
2. 서버에서 초기값으로 부터 ACK 번호를 산출하여 클라이언트에 반송한다.
3. 클라이언트에서도 마찬가지로 시퀀스 번호의 초기값으로부터 ACK번호를 산출하여 서버에 반송한다.

시퀀스 번호와 ACK 번호가 준비되었으므로 데이터 송/수신 동작에 들어간다.

4. 웹의 경우 최초에 클라이언트에서 서버로 메시지를 보낸다.
5. 데이터를 수신한 서버에서 ACK번호를 반송한다.

<br>

TCP는 이러한 방법으로 상대가 데이터를 받은 것을 확인하는데, 확인할 때 까지 송신한 패킷을 송신용 버퍼 메모리 영역에 보관해 둔다.
<br>

송신한 데이터에 대응하는 ACK 번호가 상대로부터 돌아오지 않으면 패킷을 다시 보낸다.
<br>

네트워크가 끊어 질 경우 TCP는 몇 번 다시 보낸 후 회복의 전망이 없는 것으로 보고 데이터 송신 동작을 강제로 종료하고 애플리케이션에 오류를 통지한다.

### 4. 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다
<br>

ACK 번호가 돌아오는 것을 기다리는 시간
→ **타임아웃 값**
<br>

네트워크의 상황이 따라 대응할 수 있도록 TCP는 대기 시간을 동적으로 변경하는 방법을 취하고 있다.
<br>

ACK 번호가 돌아오는 시간을 기준으로 대기시간을 판단한다.

### 5.윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다

- 핑퐁 방식
    - 클라이언트 측에서 ACK 수신을 기다린다.
    
    단점
    
    - ACK를 기다리는 시간이 낭비된다
- 윈도우 제어 방식
    - ACK 번호를 기다리는 사이 계속해서 패킷을 수신측에 송신한다.
<br>

핑퐁 방식의 단점때문에 윈도우 제어방식을 사용한다.
<br>

윈도우 제어 방식을 사용했을때의 문제점은 수신측의 버퍼메모리를 초과할 만큼(애플리케이션에 건네줘도 송신측이 더 빠를경우) 송신측에서 패킷을 보냈을 때이다.
<br>

**해결방법**
<br>

수신측에서 송신측에 수신 가능한 데이터양을 통지하고, 수신측은 이 야을 초과하지 않도록 송신 동작을 실행한다.
<br>

수신측에서 수신 처리가 끝나고 수신 버퍼에 빈 부분이 생기면 그 분량만큼 수신할 수 있는 데이터의 양을 늘리므로TCP 헤더의 **윈도우 필드**에서 이것을 송신측에 알린다.
<br>

수신 가능한 데이터의 양의 최대값을 **윈도우 사이즈(보통 수신측의 버퍼 메모리 크기와 같다)**라고 부른다. TCP를 정밀 조정하는 매개변수중 하나이다.

### 6. ACK 번호와 윈도우를 합승한다

수신측에서 애플리케이션에 데이터를 건네주고 수신 버퍼의 빈 영역이 늘어났을 때 이것을 송신측에 통지해야 하는데, 이것이 **윈도우 통지**의 타이밍이다.
<br>

ACK는 데이터를 받았을때 내용을 조사하여 정상 수신을 확인할 수 있는 경우에만 송신측에 보낸다.
<br>

즉 데이터를 수신한 후 즉시 보낸다.
<br>

수신측에서 ACK 번호나 윈도우를 통지할때 바로바로 보내면 송신측에 보내는 패킷이 많아져서 효율성이 적어진다.
<br>

따라서 소켓을 바로 보내지 않고 잠시 기다리다가 다음 통지 동작이 일어나면 양쪽을 상승시켜서 한개의 패킷으로 묶어서 보낸다.(패킷의 수를 줄일 수 있다)
<br>

ACK번호 통지가 연속하여 일어나도 최후의 것만 통지하고 도중의 것을 생략해도 된다.
→ 패킷을 줄일 수 있음
<br>

윈도우 통지도 마찬가지 수신버퍼가 점점 늘어나는 상황이라 기다려도 된다.

### 7. HTTP 응답 메시지를 수신한다

브라우저는 리퀘스트 메시지를 송신해 달라고 의뢰하고, 이것이 끝나면 서버에서 돌아오는 응답 메시지를 받기 위해 read 프로그램을 호출한다.
<br>

read를 경유하여 프로토콜 스택에 제어가 넘어가고, 프로토콜 스택이 움직이기 시작한다.
<br>

리퀘스트 메시지의 송신을 완료하고 나서 얼마 안된 시점일 경우 응답메시지가 돌아오지 않는데, 응답 메시지가 돌아올 때까지 다소 시간이 걸리므로 더 이상 작업을 진행할 수 없다.
<br>

따라서 프로토콜 스택은 수신버퍼에서 데이터를 꺼내 애플리케이션에 건네주는 작업을 잠시 보류한다. (다수의 애플리케이션에서 의뢰받은 작업을 수행하므로 다른 진행 가능한 작업을 실행한다)
<br>

서버에서 응답 메시지의 패킷이 도착했을 때 그것을 수신하여 애플리케이션에 건네주는 작업을 재개한다.

## 4. 서버에서 연결을 끊어 소켓을 말소한다.

### 1. 데이터 보내기를 완료했을 때 연결을 끊는다

서버측에서 연결 끊기 단계에 들어가는 기준으로 설명
<br>

서버측 애플리케이션이 먼저 Socket 라이브러리의 close를 호출한다.
<br>

서버측의 프로토콜 스택이 TCP 헤더를 만들고, 여기에 연결끊기를 나타내는 정보를 설정한다.
<br>

컨트롤 비트의 FIN 비트에 1을 설정하고, IP 담당 부분에 의뢰하여 클라이언트에 송신해 달라고 한다.
<br>

이와 동시에 서버측의 소켓에 연결 끊기 동작에 들어갔다는 정보를 기록한다.
<br>

클라이언트 측의 프로토콜 스택은 서버에서 FIN에 1을 설정한 TCP 헤더가 도착하면 자신의 소켓에 서버측이 연결 끊기 동작에 들어갔다는 것을 기록한다.
<br>

잠시 후 애플리케이션이 read를 호출하면 서버에서 보낸 데이터를 전부 수신 완료했다는 사실을 클라이언트측의 브라우저에게 알린다.
<br>

클라이언트 측의 애플리케이션도 close를 호출하여 송/수신 동작을 끝낸다.
<br>

클라이언트 측의 프로토콜 스택도 서버측과 마찬가지로 FIN 비트에 1을 설정한 TCP 헤더를 만들고 IP 담당 부분에 의뢰하여 서버에 송신한 후 서버에서 ACK 번호가 돌아오면 서버와의 대화가 끝난다.

### 2. 소켓을 말소한다

서버와의 대화가 끝나면 소켓을 오동작을 막기 위해 바로 말소하지 않고 잠시 기다린다.
<br>

서버가 FIN을 보낸것에 대해 클라이언트가 ACK 응답이 없을 시 서버는 FIN을 다시 보내게 된다.
<br>

이때 만약 소켓이 말소 된다면 기록되어 있던 제어 정보가 없어지므로 소켓에 할당되어 있던 포트 번호도 몇번인지 알 수 없게 된다. 
<br>

이 시점에서 다른 애플리케이션이 소켓을 작성하면 새 소켓에 같은 포트 번호가 할당될 수 있는데 패킷을 다시 보내는 동작을 하게 되면 다른 애플리케이션이 종료 동작을 할 경우가 생긴다.